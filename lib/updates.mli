(** This module is a helper for interfaces of a particular shape.
 *
 * The idea is that updates are generated by a component when another
 * component should be notified of events. For example, when a VM changes
 * state, xenopsd uses this interface so that xapi knows something has
 * changed. The updates contain no information other than that something
 * has changed, so additionally the interface needs to have some sort of
 * mechanism for querying the current state of the object in question.
 *
 * This module provides functions for adding updates, adding barriers
 * (which contain a snapshot of the current updates), and a blocking call to
 * that returns the latest set of updates, optionally given a token that
 * represents the last set of updates received.
*)

module type INTERFACE =
sig
  val service_name : string
  module Dynamic :
  sig type id val rpc_of_id : id -> Rpc.t val id_of_rpc : Rpc.t -> id end
end

module Updates :
  functor (Interface : INTERFACE) ->
  sig
    type id = int

    (* Updates are kept in a `t` *)
    type t

    (* Create an empty updates recorder using the given scheduler *)
    val empty : Scheduler.t -> t

    (* last_id [dbg] [t] returns the last id that's in use in [t] *)
    val last_id : string -> t -> int

    (* The return type for `get`. Returns a list of barriers, then a list of updates, then a token
       to pass to the next invocation of `get` *)
    type get_result = (int * Interface.Dynamic.id list) list * Interface.Dynamic.id list * id

    (* [get dbg ?with_cancel from timeout t] is a blocking call that will return all the updates
       recorded in [t] since [from] (or for all time if [from] is None). [timeout], if it is
       not None, is the timeout in seconds to wait. [dbg] is a debug string. [with_cancel] is
       a function passed in that allows this call to be cancelled. See Task_server.with_cancel
       for an example function that may be used *)
    val get :
      string ->
      ?with_cancel:((unit -> unit) ->
                    (unit -> get_result) -> get_result) ->
      id option ->
      int option -> t -> get_result

    (* Add an update to a particular type of item (e.g. 'VM' or 'VBD', defined in INTERFACE) *)
    val add : Interface.Dynamic.id -> t -> unit

    (* Remove an update *)
    val remove : Interface.Dynamic.id -> t -> unit

    (* Filter updates to remove those that don't satisfy the predicate passed in *)
    val filter : (Interface.Dynamic.id -> bool) -> t -> unit

    (* [inject_barrier n p t] Inject a barrier identified by [n] into [t]. The barrier will contain a
       snapshot of all current updates that match the predicate [p]. *)
    val inject_barrier : int -> (Interface.Dynamic.id -> int -> bool) -> t -> unit

    (* Removes a barrier *)
    val remove_barrier : int -> t -> unit

    (* The Dump module is to dump the internal state of the Updates value for debugging
       purposes *)
    module Dump :
    sig
      type u = { id : int; v : string; }
      type dump = {
        updates : u list;
        barriers : (int * int * u list) list;
      }
      val rpc_of_dump : dump -> Rpc.t
      val dump_of_rpc : Rpc.t -> dump
      val make : t -> dump
    end

  end
