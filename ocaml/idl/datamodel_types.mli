module Date : sig
  include module type of Xapi_stdext_date.Date

  val iso8601_of_rpc : Rpc.t -> Xapi_stdext_date.Date.iso8601

  val rpc_of_iso8601 : Xapi_stdext_date.Date.iso8601 -> Rpc.t
end

val oss_since_303 : string option

val rel_george : string

val rel_orlando : string

val rel_orlando_update_1 : string

val rel_symc : string

val rel_miami : string

val rel_rio : string

val rel_midnight_ride : string

val rel_cowley : string

val rel_boston : string

val rel_tampa : string

val rel_clearwater : string

val rel_vgpu_tech_preview : string

val rel_vgpu_productisation : string

val rel_clearwater_felton : string

val rel_clearwater_whetstone : string

val rel_creedence : string

val rel_cream : string

val rel_indigo : string

val rel_dundee : string

val rel_ely : string

val rel_falcon : string

val rel_inverness : string

val rel_jura : string

val rel_kolkata : string

val rel_lima : string

val rel_naples : string

val rel_oslo : string

val rel_quebec : string

val rel_stockholm : string

val rel_stockholm_psr : string

type api_release = {
    code_name: string option
  ; version_major: int
  ; version_minor: int
  ; branding: string
  ; release_date: string option
}

val release_order_full : api_release list

val release_order : api_release list

exception Unknown_release of string

exception UnspecifiedRelease

val code_name_of_release : api_release -> string

val version_leq : string -> string -> bool

val release_leq : string -> string -> bool

(** Types of object fields. Accessor functions are generated for each field
    automatically according to its type and qualifiers. *)
type ty =
  | SecretString
  | String
  | Int
  | Float
  | Bool
  | DateTime
  | Enum of string * (string * string) list
  | Set of ty
  | Map of ty * ty
  | Ref of string
  | Record of string
  | Option of ty

val rpc_of_ty : ty -> Rpc.t

val ty_of_rpc : Rpc.t -> ty

type api_value =
  | VString of string
  | VInt of int64
  | VFloat of float
  | VBool of bool
  | VDateTime of Date.iso8601
  | VEnum of string
  | VMap of (api_value * api_value) list
  | VSet of api_value list
  | VRef of string

val rpc_of_api_value : api_value -> Rpc.t

val api_value_of_rpc : Rpc.t -> api_value

val null_ref : string

(** Each database field has a qualifier associated with it:
    - "Static" means the initial value is specified as a parameter in the
        object constructor.
    - "Dynamic" means the opposite: its initial value is a predefined default.
    - "RW" means the value can be updated by XenAPI clients via the
      autogenerated API.
    - "RO" means the opposite, but the value can be updated by direct database
      calls. *)
type qualifier =
  | RW  (** Implicitly static: set in constructor and updatable through API *)
  | StaticRO
      (** Specified in constructor; no autogenerated setter in XenAPI. *)
  | DynamicRO
      (** Initial value is a default; no autogenerated setter in XenAPI. *)

val rpc_of_qualifier : qualifier -> Rpc.t

val qualifier_of_rpc : Rpc.t -> qualifier

type release = {
    opensource: string list
  ; internal: string list
  ; internal_deprecated_since: string option
}

val rpc_of_release : release -> Rpc.t

val release_of_rpc : Rpc.t -> release

(** Model lifecycle of fields and messages, this restricts how can they change
    in the API *)
module Lifecycle : sig
  exception Invalid of string

  type state =
    | Unreleased_s
    | Prototyped_s
    | Published_s
    | Deprecated_s
    | Removed_s

  type change =
    | Prototyped
    | Published
    | Extended
    | Changed
    | Deprecated
    | Removed

  type transition = change * string * string

  type t = private {state: state; transitions: transition list}

  val rpc_of_transition : change * string * string -> Rpc.t

  val transition_of_rpc : Rpc.t -> change * string * string

  val string_of_change : change -> string

  val string_of_state : state -> string

  val from : transition list -> t
  (** [from transitions] returns the lifecycle defined by [transitions] if the
      sequence is valid, otherwise raises [Invalid_lifecycle]. *)
end

(** Messages are tagged with one of these indicating whether the message was
    specified explicitly in the datamodel, or is one of the automatically
    generated ones. If automatically generated, the tag tells you where it came
    from: this is needed for the server implementation. *)
type tag = FromField of field_op * field | FromObject of obj_op | Custom

and field_op = Getter | Setter | Add | Remove

and private_op = GetDBRecord | GetDBAll | Copy

and obj_op =
  | Make
  | Delete
  | GetByUuid
  | GetByLabel
  | GetRecord
  | GetAll
  | GetAllWhere
  | GetAllRecordsWhere
  | GetAllRecords
  | Private of private_op

and param = {
    param_type: ty
  ; param_name: string
  ; param_doc: string
  ; param_release: release
  ; param_default: api_value option
}

and doc_tag = VM_lifecycle | Snapshots | Networking | Memory | Windows

and forward = Extension of string | HostExtension of string

(** Types of RPC messages; in addition to those generated for object fields *)
and message = {
    msg_name: string
  ; msg_params: param list
  ; msg_result: (ty * string) option
  ; msg_errors: error list
  ; msg_doc: string
  ; msg_async: bool
  ; msg_session: bool
  ; msg_secret: bool  (** Do no log this message *)
  ; msg_pool_internal: bool  (** Only allow on "pool-login" sessions *)
  ; msg_db_only: bool  (** Do not expose through API *)
  ; msg_release: release
  ; msg_lifecycle: Lifecycle.t
  ; msg_has_effect: bool
        (** Whether the message appears in the custom operations *)
  ; msg_force_custom: qualifier option
        (** [msg_force_custom (Some (RO|RW))] always forces the message into
        custom operations, see gen_empty_custom.ml *)
  ; msg_no_current_operations: bool
        (** Whether it's hidden from current operations *)
  ; msg_tag: tag
  ; msg_obj_name: string
  ; msg_custom_marshaller: bool
  ; msg_hide_from_docs: bool
        (** Hide the message in the documentation and do not include it in the
            SDK *)
  ; msg_allowed_roles: string list option
  ; msg_map_keys_roles: (string * string list option) list
  ; msg_doc_tags: doc_tag list
  ; msg_forward_to: forward option  (** proxy the RPC elsewhere *)
}

and field = {
    release: release
  ; lifecycle: Lifecycle.t
  ; field_persist: bool
  ; default_value: api_value option
  ; internal_only: bool
  ; qualifier: qualifier
  ; field_name: string
  ; full_name: string list
  ; ty: ty
  ; field_description: string
  ; field_has_effect: bool
  ; field_ignore_foreign_key: bool
  ; field_setter_roles: string list option
  ; field_getter_roles: string list option
  ; field_map_keys_roles: (string * string list option) list
  ; field_doc_tags: doc_tag list
}

and error = {err_name: string; err_params: string list; err_doc: string}

and mess = {mess_name: string; mess_doc: string}

val rpc_of_tag : tag -> Rpc.t

val tag_of_rpc : Rpc.t -> tag

val rpc_of_field_op : field_op -> Rpc.t

val field_op_of_rpc : Rpc.t -> field_op

val rpc_of_private_op : private_op -> Rpc.t

val private_op_of_rpc : Rpc.t -> private_op

val rpc_of_obj_op : obj_op -> Rpc.t

val obj_op_of_rpc : Rpc.t -> obj_op

val rpc_of_param : param -> Rpc.t

val param_of_rpc : Rpc.t -> param

val rpc_of_doc_tag : doc_tag -> Rpc.t

val doc_tag_of_rpc : Rpc.t -> doc_tag

val rpc_of_forward : forward -> Rpc.t

val forward_of_rpc : Rpc.t -> forward

val rpc_of_message : message -> Rpc.t

val message_of_rpc : Rpc.t -> message

val rpc_of_field : field -> Rpc.t

val field_of_rpc : Rpc.t -> field

val rpc_of_error : error -> Rpc.t

val error_of_rpc : Rpc.t -> error

val rpc_of_mess : mess -> Rpc.t

val mess_of_rpc : Rpc.t -> mess

val default_message : message

(** Getters and Setters will be generated for each field, depending on the qualifier.
    Namespaces allow fields to be grouped together (and this can get reflected in the XML
    document structure)
*)
type content =
  | Field of field  (** An individual field *)
  | Namespace of string * content list
      (** A nice namespace for a group of fields *)

val rpc_of_content : content -> Rpc.t

val content_of_rpc : Rpc.t -> content

type persist_option = PersistNothing | PersistEverything

val rpc_of_persist_option : persist_option -> Rpc.t

val persist_option_of_rpc : Rpc.t -> persist_option

type db_logging = Log_destroy

val rpc_of_db_logging : db_logging -> Rpc.t

val db_logging_of_rpc : Rpc.t -> db_logging

(** An object (or entity) is represented by one of these: *)
type obj = {
    name: string
  ; description: string
  ; obj_lifecycle: Lifecycle.t
  ; contents: content list
  ; messages: message list
  ; doccomments: (string * string) list
  ; gen_constructor_destructor: bool
  ; force_custom_actions: qualifier option
  ; obj_allowed_roles: string list option
        (** for construct, destruct and explicit obj messages *)
  ; obj_implicit_msg_allowed_roles: string list option
        (** for all other implicit obj messages *)
  ; gen_events: bool
  ; persist: persist_option
  ; obj_release: release
  ; in_database: bool
  ; obj_doc_tags: doc_tag list
  ; db_logging: db_logging option
}

val rpc_of_obj : obj -> Rpc.t

val obj_of_rpc : Rpc.t -> obj

(** A relation binds two fields together *)
type relation = (string * string) * (string * string)

(* Check whether a value is of the given type *)
val type_checks : api_value -> ty -> bool
